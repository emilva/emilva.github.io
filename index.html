<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Floating Text in Water - Three.js</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script>
    let scene, camera, renderer, textMesh, waterPlane, clock;

    function init() {
      // Create scene
      scene = new THREE.Scene();

      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 20, 150);

      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create clock to keep track of time for water ripple
      clock = new THREE.Clock();

      // Load Font and Create Text
      let fontLoader = new THREE.FontLoader();
      fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        let textGeometry = new THREE.TextGeometry('vaag.land', {
          font: font,
          size: 20,
          height: 5,
          curveSegments: 12,
          bevelEnabled: true,
          bevelThickness: 2,
          bevelSize: 1.5,
          bevelOffset: 0,
          bevelSegments: 5
        });

        let textMaterial = new THREE.MeshPhongMaterial({ color: 0x88B04B, shininess: 100 });
        textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textGeometry.center(); // Center the text

        // Position above the water
        textMesh.position.y = 15;

        // Add text to scene
        scene.add(textMesh);
      });

      // Create light
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(100, 100, 100);
      scene.add(light);

      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      // Create water plane
      const waterGeometry = new THREE.PlaneGeometry(500, 500, 32, 32);
      const waterMaterial = new THREE.MeshPhongMaterial({
        color: 0x0088ff,
        shininess: 100,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide,
      });
      waterPlane = new THREE.Mesh(waterGeometry, waterMaterial);
      waterPlane.rotation.x = -Math.PI / 2; // Rotate to make it flat
      waterPlane.position.y = 0; // Position at y = 0

      // Store original positions for wave calculations
      waterPlane.geometry.attributes.position.originalPosition = waterPlane.geometry.attributes.position.array.slice();

      scene.add(waterPlane);

      // Start the animation loop
      animate();
    }

    // Animate the scene
    function animate() {
      requestAnimationFrame(animate);

      // Get elapsed time for water ripples
      const elapsedTime = clock.getElapsedTime();

      // Animate the water ripple by modifying vertex positions in the buffer attribute
      const position = waterPlane.geometry.attributes.position;
      const originalPosition = position.originalPosition;

      for (let i = 0; i < position.count; i++) {
        const x = originalPosition[i * 3];
        const y = originalPosition[i * 3 + 1];
        const z = originalPosition[i * 3 + 2];

        const waveSpeed = 0.05;
        const waveHeight = 1.5;
        position.array[i * 3 + 2] = z + Math.sin(x * waveSpeed + elapsedTime) * waveHeight;
      }

      position.needsUpdate = true; // Notify Three.js that vertices have been updated

      // Make the text float up and down
      if (textMesh) {
        textMesh.position.y = 15 + Math.sin(elapsedTime * 1.5) * 2; // Bobbing up and down
        textMesh.rotation.y += 0.01; // Add some rotation for extra effect
      }

      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', function() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // Initialize the scene
    init();
  </script>
</body>
</html>
